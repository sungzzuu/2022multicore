220913

Data Race -> lock, unlock으로 해결

77
서로 다른 mutex객체는 서로 모른다. DataRace를 막기 위해서는 같은 mutex 객체를 사용해야 한다.
Data Race가 일어나지 않는 부분은 다른 mutex 객체로 해준다.

78
스레드 1과 스레드2,3은 동시에 실행되면 안된다.
스레드1,2,3과 스레드 4,5는 동시에 실행해도 된다. => Data Race가 아님. 서로 다른 메모리에 쓰는 것은 Data Race가 아님.

79
올바른 결과가 나오지만 너무 느리다.

참고는 리눅스 예제 소개 정도만. 이런 API 아무도 안씀.

88
속도 비교. ns 단위로 계산할 수 있다.
 
92
Release => 성능측정

96
비주얼에서 알아서 루프를 도는게 아닌 직접 계산을 해서 data race가 일어나지 않는다. => 성능측정 불가능
volatile <-> register 최적화<->성능최대. CPU까지 안감.

99
lock을 어떻게 안쓰지?다른 스레드가 sum을 건들지 못하도록 한다. => atomic하게 실행시킨다.
하지만, 어셈블리를 사용하는건 좀 그렇다...

C++11에서 atomic연산을 지원한다. atomic 연산은 실행순서는 프로그래밍 순서를 따르고. vs가 최적화할 수 없다. 다른 연산이 끼어들 수 없다.
어떤 스레드에서 봐도 항상 같은 순서로 실행되므로 결과는 항상 같다. => lock보단 빠르지만 스레드의 개수가 늘어난다고 속도가 빨라지진 않는다.
모든 스레드에서 동일 하게 관찰된다??=> 나중에...
결론: atomic 연산은 data race가 일어나지 않는다. 

vs에서 x64에서는 어셈블리어를 수행할 수 없도록 함.

114
올바른 값은 나오나, 성능의 스레드 개수만큼 올라가지 않음. => 캐시 트레싱 때매

115 ★★
배열은 메모리가 붙어있어서 한 캐시라인에 들어간다. 메모리에서 읽어와서 더해야하는데, 캐시는 한 워드만 읽는게 아닌 캐시라인을 통째로 읽어온다.
=> 옆의 다른 값도 불러온다. sum1 작업 중에 sum0 수정하려면 이미 읽어가서 읽을 캐시라인이 invalidate되면 메모리에서 읽을 수 있다. 캐시라인이 코어끼리
핑퐁 현상이 일어나서 속도가 떨어진다. => data race 문제가 아님. 최신 cpu는 데이터를 메모리에 적지 않고 직접 보내서 그나마 빠르다.
=> 같은 캐시라인에 위치하지 않도록 한다. 배열의 크기를 키우고 띄엄띄엄 위치하도록 하면 다시 정답!!!

116
lock을 사용하지 않고 멀티스레딩을 할 수 있도록!

119
멀티미디어에서는 멀티스레드가 잘 구현되고 있음. 코어의 개수가 많을 수록 인코딩속도가 빠르다. lock을 할 필요가 없다.
key frame 단위라서.
옛날부터 멀티스레딩 적용하고 있음. 리니지.


OpenGL -> 멀티스레딩 안되서 최적화가 어렵다. => vulkan
DX12를 사용하는게 멀티스레드때문

0926

42
멀티스레드 사용 시의 문제 (data race 이외에)
컴파일러			- volatile
CPU - out of order		- atomic_thread_fence -> 얘도 많이 쓰면 성능 저하. 파이프라인을 멈추니까
CPU - cache		- 잘 쓰자.	

피터슨도 동작하지 않음...

C++11에서 atomic  메모리 나옴. 동시에 읽고 쓸 수 있으니, 뒤섞이지 않게 컴파일 해라.
atomic<int> - 뮤텍스보다는 빠르나 시간이 int보단 더 걸림. 오버헤드가 뮤텍스보다 굉장히 적다.
싱글스레드는 신경안써도됨. 싱글 코어 내부에서는 자체적으로 보정을 한다.
캐시의 일관성? -> 같은 메모리를 다른 코어가 동시에 가질 수는 있어도 값이 틀릴 수는 없다.

atomic memory -> 3가지 문제가 일어나지 않음.
fence 명령어는 모든 cpu에 있다.

atomic memory의 옵션
seq_cst ... atomic한 api를 쓸때 이러한 옵션을 넣는 경우가 있음
seq_cst만 알면됨. 이것만 쓰면 된다. 다른걸 사용하면 위험..

멀스 기법 비교
no lock		50-	1607
atomix<int>	100-	708	-> 이걸 사용하는 이유
peterson		99-	2368
peterson_atomic	100-	4000
peterson_atf	100-	2400

aft는 에러날 확률이 줄어든거지 에러가 날 수있다. 

flag만 atomic으로 만들면?
정확한 결과가 나오지 않음.
컴파일러가 마음대로 순서 바꾼다.
atomic한 메모리 사이에 있는것들은 atomic하다. => 보장할 수 없다. 순서가 중요한건 다 atomic 메모리를 사용해야한다.

스레드끼리 데이터를 주고 받는 것 -> 동기화
자료구조는 atomic하게 동작하지 않는다.

sum += 2 		-> atomic
sum = sum +2 	-> atomic x

효율적인 자료구조★
결과가 올바르고 성능이 빠른것
mutex가 있으면 병렬성이 없음.-> 성능이 올라가지 않음
동시에 실행되지 않고 스레드가 멈추는게 성능 저하의 주범
상대방이 flag를 바꿔주기를 기다린다 -> 이런 코드를 쓰면 lock이랑 같다. 피터슨에 while이 있었음.
상대방 스레드에 의존적이지 않게 해야. 내가 할일이 있으면 그냥 하도록 해야한다.

기존 기다리는거 -> 블럭킹
atomic을 쓰는건 넌블럭킹

우선순위가 정해져있는경우 -> enqueue가 더 우선순위가 높다.  enqueue를 빨리해야 프로그램이 빨리 끝남.
cpu의 코어 개수보다 많은 스레드를 절대 만들지 말 것 !! cpu 전체가 먹통이 될 수 있다.

lock free가 더 많음. 모든이 아닌 적어도 한 개가 유한한 단계에 마침.
나머지가 영원히 뒤로 밀리면 안됨. 나머지도 유한한 단계에 끝나야. 유한한 단계 x메소드의 개수 에 끝나야.
옆애가 밀리면 다른애가 끝난다.

wait -free 보다 lock-free가 더 성능이 좋다.

0927

2-63
기아 - 자주 일어나지 않음.
퀵소트 대신 소트를 쓰는거랑 비슷.

64 -패스
성능을 위해 넌블럭킹 자료구조 사용해야. 실습하면서 얼마나 빠른지 보기로
aomic_bool ... 말고도 atomic한 자료구조가 필요

4. 동기화 연산과 CAS
CAS를 알아야 넌블럭킹 알고리즘을 만들 수 있다.
실제 메모리는 atomic하지 않음. victim, flag를 atomic하게 하면 atomic한 결과가 나옴
map, list, stack ...을 atomic memory로 만들 수 없다.

atomic memory로는 충분하지 않다. -> CompareAndSet() 연산 사용
CompareSet은 동기화 연산 중에 하나. +=도 동기화 연산. wait-free로 동작
wait-free 하지않은 동기화 연산을 가지고 동기화 연산을 만들 수  없다.
compare and set CAS - 함수. 메머리에 단순하게 write하는게 아님. 확인후 write. 조건부 쓰기. 성공여부 반환
원래 값이 expected와 같은지 확인한다.
내용은 간단. 하지만. 10의 코드는 atomic하게 동작하지 않으므로 wait-free가 아님 ==> CAS연산이 아님.
프로그램으로 구현할 수 없고 하드웨어로 구현이 되어야 함
wait-free한 cas 명령어를 intel이 만들어 놓음.
12 사용하면 멀티스레드로 동작함. 알고리즘 많이 복잡하지 않음.
but, 성능이 구림. 매우 느림
32코어여도 성능차이가 10배 이상! wait-free하게 하는건 가능한데 오버헤드가 너무 크다.
고성능 알고리즘은 lock-free알고리즘을 만들어야함.
많은 lock free 알고리즘이 나왔다. 이미 만들어져 있는거 쓰면 됨.
intel TBB thread building block

atomic_compare_exchange를 사용. set대신~
-> cas 쉽게 구현. 메모리 값이 같으면 바꾸고 아니면 건드리지 않음. 
주소, 기대값, 새 값. 주소를 넘겨주어서 set하는게 아니라 교환(sxchange)함. cas를 간단하게 구현가능.
2-18 함수만 사용하면 된다.
메모리(주소값)을 atomic 메모리를 넘겨야 한다. 하지만, 대부분 volatile을 사용. 부하가 많이 일어나서.
2-19는 C++11 이전에 사용하던거

1003

Bakery - 복잡한 알고리즘, 낮은 성능, 특수 명령 필요

2-24
compxchg -> 같으면 쓰고 아니면 안쓰고를 하나의 명령어로 실행. lock-> atomic하게 실행
lock compxchg 명령어 !
ARM cpu : 명령어 하나로 복잡한 동작을 할 수 없음.복잡한 명령어 -> 파이프라인 복잡해짐.
-LDREX		: 레지스터에서 값을 exclusive하게 읽어라
-STREXEQ	: 레지스터값을 exclusive하게 저장해라. 읽었을때랑 쓸때 다른 스레드가 건들였는지 확인하고 건들였으면 실패해라.
- . 		=> 여러개의 명령어로 구현함.

빵집 알고리즘의 문제 -> 어느 시점부터 너무 느려짐 convoying
결론: atomic한 자료구조를 써라

5. 병렬 알고리즘 LIST

2-2
논블로킹 자료구조: linked list
삽입, 삭제가 o(n)
ordered set : 데이터가 중복이 안된다. 순서대로 저장된다.

숙제3
클래스의 멤버로 뮤텍스를 가진다.
head는 바뀌지 않아서 lock할 필요 없음


1004

2-17
리스트에서 서로 붙어있을때만 lock을 걸고 멀리 있을 경우 lock을 사용하지 않아도 된다.
검색을 하면서 이동할때도 lock을 해야 한다.

2-29
터지는 이유

2-33
처음부터 검색해서 있다 -> 있는거. 다른 스레드가 삭제할 수 없다.lock을 걸어놨기 때문에. unlock을 할때까지는 지워지지 않는다.
유효성 검사 -> 처음부터 돌면서 pred->next == curr인지 확인한다.

1010
2-27
이동 시 잠금을 하지 않으면-> 오동작하고 크래시가 나는데, 이를 막아서 잠금을 하지 않아도 돌아가게하자!

2-31
제대로된 노드인가 검사를 해야함. - 유효성 검사
=> 두개의 노드가 리스트에 있는가(pred있는지). 다른 노드가 끼어들었나(pred다음에 curr가 있는지)
검사 후에는 안심하고 사용할 수 있다.

2-34
유효성검사 실패시 처음부터 다시. lock을 unlock하고 다시 한다. 유효성검사가 성공할때까지
계속 실패할 수 있지만 -> 고려하지 않음.
기아-> 계속 실패확률이 높을때 고려하면 됨.

2-35,36
처음 검색할때는 lock하지 않음.
검색이 끝나면 add하기 전에 lock한다.
유효성검사 (pred, curr)을 한다. -> 유효성검사가 실패하면 계속 반복 수행한다.
노드를 add한다.
unlock한다.
아직 싱글스레드일때 2배 느리다. 쿼드코어는 되야 약간 빨라짐.
메모리 leak이 있음

2-44
순회를 두번해야함 -> 두배의 시간 걸림
처음부터 수행하지않고 validate를 수행할 수 있어야
Contains() 은 locking을 뺄수 있다. => 게으른 동기화에서는
remove 여부 판단을 위해 확인했던것.
노드에다가제거 여부 표시하도록하자 => marked (원래 removed가 적당함)
false로 생성하고 remove할때 true로 바꾼다. remove메소드말고 노드에서 빼내는 방법은 없다.
노드를 삭제하기전에 해야한다!!
검색은 lock을 하지 않으니 순서가 중요
marked가 false인 노드는 리스트에 존재한다.
marked가 true인 노드는 리스트에 존재하지 않는다. => 나중에 지우면 이상황임. false인 노드는 리스트에 존재하지 않을 수도 있다


contains는 lock-free가 아닌 wait-free. 스레드 개수와 상관없이 속도 같음
다른 스레드와 충돌 검사를 안하면 wait-free. 

1011 
2-52부터 아이패드

1017 월
중간고사 - 24일

2-93
curr부터 실패하면 ㄱㅊ음.
curr은 성공하고 pred->next = curr->next 가 실패하면 문제가 된다.
중간에 pred가 지워지거나 pred와 curr 사이에 노드가 추가되면 문제가 된다.
2-94 
실패했을 경우 그냥 냅둔다. marking된 노드가 존재하는건 문제 => 리스트 재정의
중간 marking된 노드가 있어도 리스트라고 인정 한다.
문제
1. 마킹된 스레기들 계속 증가함
2. add, remove 알고리즘 실행 시 기존의 알고리즘 제대로 동작 안함.
=> 메소드 모두 새로 작성. 스레기가 있어도 잘 동작하도록.
=> 마킹된 노드를 지우면서 검색을 한다. remove뿐만 아닌 모든 메소드에서
add, remove는 그대로 . 뒤처리 함수 추가
compareAndSet -> 다른 스레드와 충돌 판정. CAS
다른 스레드와 충돌해 뒷수습에 문제가 된다면 무조건 head부터 다시 탐색

ADD
1. find
2. 이미 있으면 안넣고 없으면 CAS를 통해 넣음.  실패하면 첨부터 다시 -> delete하고

REMOVE
curr부터 실패하면 ㄱㅊ음.
curr은 성공하고 pred->next = curr->next 가 실패하면 문제가 된다. 그러나 그냥 냅둔다.

CONTAINS
게으른 그대로

2-99
포인터, 마킹얻기, 마킹하기, CAS 메소드 구현
next를 새로운 클래스 정의하여 바꾸기-> 디버깅이 불편.이거 사용 or 그대로 하되 주의깊게 쓴다. mark를 보고

2-100
자바는 포인터 없고, 참조도 없고 2개 리턴도 없음.-> 클래스를 리턴하는것밖에 안된다. => window 클래스 따로 만들필요없다.


























































