220913

Data Race -> lock, unlock으로 해결

77
서로 다른 mutex객체는 서로 모른다. DataRace를 막기 위해서는 같은 mutex 객체를 사용해야 한다.
Data Race가 일어나지 않는 부분은 다른 mutex 객체로 해준다.

78
스레드 1과 스레드2,3은 동시에 실행되면 안된다.
스레드1,2,3과 스레드 4,5는 동시에 실행해도 된다. => Data Race가 아님. 서로 다른 메모리에 쓰는 것은 Data Race가 아님.

79
올바른 결과가 나오지만 너무 느리다.

참고는 리눅스 예제 소개 정도만. 이런 API 아무도 안씀.

88
속도 비교. ns 단위로 계산할 수 있다.
 
92
Release => 성능측정

96
비주얼에서 알아서 루프를 도는게 아닌 직접 계산을 해서 data race가 일어나지 않는다. => 성능측정 불가능
volatile <-> register 최적화<->성능최대. CPU까지 안감.

99
lock을 어떻게 안쓰지?다른 스레드가 sum을 건들지 못하도록 한다. => atomic하게 실행시킨다.
하지만, 어셈블리를 사용하는건 좀 그렇다...

C++11에서 atomic연산을 지원한다. atomic 연산은 실행순서는 프로그래밍 순서를 따르고. vs가 최적화할 수 없다. 다른 연산이 끼어들 수 없다.
어떤 스레드에서 봐도 항상 같은 순서로 실행되므로 결과는 항상 같다.
모든 스레드에서 동일 하게 관찰된다??=> 나중에...
결론: atomic 연산은 data race가 일어나지 않는다. 

vs에서 x64에서는 어셈블리어를 수행할 수 없도록 함.










