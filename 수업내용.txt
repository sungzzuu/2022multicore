220913

Data Race -> lock, unlock으로 해결

77
서로 다른 mutex객체는 서로 모른다. DataRace를 막기 위해서는 같은 mutex 객체를 사용해야 한다.
Data Race가 일어나지 않는 부분은 다른 mutex 객체로 해준다.

78
스레드 1과 스레드2,3은 동시에 실행되면 안된다.
스레드1,2,3과 스레드 4,5는 동시에 실행해도 된다. => Data Race가 아님. 서로 다른 메모리에 쓰는 것은 Data Race가 아님.

79
올바른 결과가 나오지만 너무 느리다.

참고는 리눅스 예제 소개 정도만. 이런 API 아무도 안씀.

88
속도 비교. ns 단위로 계산할 수 있다.
 
92
Release => 성능측정

96
비주얼에서 알아서 루프를 도는게 아닌 직접 계산을 해서 data race가 일어나지 않는다. => 성능측정 불가능
volatile <-> register 최적화<->성능최대. CPU까지 안감.

99
lock을 어떻게 안쓰지?다른 스레드가 sum을 건들지 못하도록 한다. => atomic하게 실행시킨다.
하지만, 어셈블리를 사용하는건 좀 그렇다...

C++11에서 atomic연산을 지원한다. atomic 연산은 실행순서는 프로그래밍 순서를 따르고. vs가 최적화할 수 없다. 다른 연산이 끼어들 수 없다.
어떤 스레드에서 봐도 항상 같은 순서로 실행되므로 결과는 항상 같다. => lock보단 빠르지만 스레드의 개수가 늘어난다고 속도가 빨라지진 않는다.
모든 스레드에서 동일 하게 관찰된다??=> 나중에...
결론: atomic 연산은 data race가 일어나지 않는다. 

vs에서 x64에서는 어셈블리어를 수행할 수 없도록 함.

114
올바른 값은 나오나, 성능의 스레드 개수만큼 올라가지 않음. => 캐시 트레싱 때매

115 ★★
배열은 메모리가 붙어있어서 한 캐시라인에 들어간다. 메모리에서 읽어와서 더해야하는데, 캐시는 한 워드만 읽는게 아닌 캐시라인을 통째로 읽어온다.
=> 옆의 다른 값도 불러온다. sum1 작업 중에 sum0 수정하려면 이미 읽어가서 읽을 캐시라인이 invalidate되면 메모리에서 읽을 수 있다. 캐시라인이 코어끼리
핑퐁 현상이 일어나서 속도가 떨어진다. => data race 문제가 아님. 최신 cpu는 데이터를 메모리에 적지 않고 직접 보내서 그나마 빠르다.
=> 같은 캐시라인에 위치하지 않도록 한다. 배열의 크기를 키우고 띄엄띄엄 위치하도록 하면 다시 정답!!!

116
lock을 사용하지 않고 멀티스레딩을 할 수 있도록!

119
멀티미디어에서는 멀티스레드가 잘 구현되고 있음. 코어의 개수가 많을 수록 인코딩속도가 빠르다. lock을 할 필요가 없다.
key frame 단위라서.
옛날부터 멀티스레딩 적용하고 있음. 리니지.


OpenGL -> 멀티스레딩 안되서 최적화가 어렵다. => vulkan
DX12를 사용하는게 멀티스레드때문

0926

42
멀티스레드 사용 시의 문제 (data race 이외에)
컴파일러			- volatile
CPU - out of order		- atomic_thread_fence -> 얘도 많이 쓰면 성능 저하. 파이프라인을 멈추니까
CPU - cache		- 잘 쓰자.	

피터슨도 동작하지 않음...

C++11에서 atomic  메모리 나옴. 동시에 읽고 쓸 수 있으니, 뒤섞이지 않게 컴파일 해라.
atomic<int> - 뮤텍스보다는 빠르나 시간이 int보단 더 걸림. 오버헤드가 뮤텍스보다 굉장히 적다.
싱글스레드는 신경안써도됨. 싱글 코어 내부에서는 자체적으로 보정을 한다.
캐시의 일관성? -> 같은 메모리를 다른 코어가 동시에 가질 수는 있어도 값이 틀릴 수는 없다.

atomic memory -> 3가지 문제가 일어나지 않음.
fence 명령어는 모든 cpu에 있다.

atomic memory의 옵션
seq_cst ... atomic한 api를 쓸때 이러한 옵션을 넣는 경우가 있음
seq_cst만 알면됨. 이것만 쓰면 된다. 다른걸 사용하면 위험..








































