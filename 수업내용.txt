220913

Data Race -> lock, unlock으로 해결

77
서로 다른 mutex객체는 서로 모른다. DataRace를 막기 위해서는 같은 mutex 객체를 사용해야 한다.
Data Race가 일어나지 않는 부분은 다른 mutex 객체로 해준다.

78
스레드 1과 스레드2,3은 동시에 실행되면 안된다.
스레드1,2,3과 스레드 4,5는 동시에 실행해도 된다. => Data Race가 아님. 서로 다른 메모리에 쓰는 것은 Data Race가 아님.

79
올바른 결과가 나오지만 너무 느리다.

참고는 리눅스 예제 소개 정도만. 이런 API 아무도 안씀.

88
속도 비교. ns 단위로 계산할 수 있다.
 
92
Release => 성능측정

96
비주얼에서 알아서 루프를 도는게 아닌 직접 계산을 해서 data race가 일어나지 않는다. => 성능측정 불가능
volatile <-> register 최적화<->성능최대. CPU까지 안감.

99
lock을 어떻게 안쓰지?다른 스레드가 sum을 건들지 못하도록 한다. => atomic하게 실행시킨다.
하지만, 어셈블리를 사용하는건 좀 그렇다...

C++11에서 atomic연산을 지원한다. atomic 연산은 실행순서는 프로그래밍 순서를 따르고. vs가 최적화할 수 없다. 다른 연산이 끼어들 수 없다.
어떤 스레드에서 봐도 항상 같은 순서로 실행되므로 결과는 항상 같다. => lock보단 빠르지만 스레드의 개수가 늘어난다고 속도가 빨라지진 않는다.
모든 스레드에서 동일 하게 관찰된다??=> 나중에...
결론: atomic 연산은 data race가 일어나지 않는다. 

vs에서 x64에서는 어셈블리어를 수행할 수 없도록 함.

114
올바른 값은 나오나, 성능의 스레드 개수만큼 올라가지 않음. => 캐시 트레싱 때매

115 ★★
배열은 메모리가 붙어있어서 한 캐시라인에 들어간다. 메모리에서 읽어와서 더해야하는데, 캐시는 한 워드만 읽는게 아닌 캐시라인을 통째로 읽어온다.
=> 옆의 다른 값도 불러온다. sum1 작업 중에 sum0 수정하려면 이미 읽어가서 읽을 캐시라인이 invalidate되면 메모리에서 읽을 수 있다. 캐시라인이 코어끼리
핑퐁 현상이 일어나서 속도가 떨어진다. => data race 문제가 아님. 최신 cpu는 데이터를 메모리에 적지 않고 직접 보내서 그나마 빠르다.
=> 같은 캐시라인에 위치하지 않도록 한다. 배열의 크기를 키우고 띄엄띄엄 위치하도록 하면 다시 정답!!!

116
lock을 사용하지 않고 멀티스레딩을 할 수 있도록!

119
멀티미디어에서는 멀티스레드가 잘 구현되고 있음. 코어의 개수가 많을 수록 인코딩속도가 빠르다. lock을 할 필요가 없다.
key frame 단위라서.
옛날부터 멀티스레딩 적용하고 있음. 리니지.


OpenGL -> 멀티스레딩 안되서 최적화가 어렵다. => vulkan
DX12를 사용하는게 멀티스레드때문

0926

42
멀티스레드 사용 시의 문제 (data race 이외에)
컴파일러			- volatile
CPU - out of order		- atomic_thread_fence -> 얘도 많이 쓰면 성능 저하. 파이프라인을 멈추니까
CPU - cache		- 잘 쓰자.	

피터슨도 동작하지 않음...

C++11에서 atomic  메모리 나옴. 동시에 읽고 쓸 수 있으니, 뒤섞이지 않게 컴파일 해라.
atomic<int> - 뮤텍스보다는 빠르나 시간이 int보단 더 걸림. 오버헤드가 뮤텍스보다 굉장히 적다.
싱글스레드는 신경안써도됨. 싱글 코어 내부에서는 자체적으로 보정을 한다.
캐시의 일관성? -> 같은 메모리를 다른 코어가 동시에 가질 수는 있어도 값이 틀릴 수는 없다.

atomic memory -> 3가지 문제가 일어나지 않음.
fence 명령어는 모든 cpu에 있다.

atomic memory의 옵션
seq_cst ... atomic한 api를 쓸때 이러한 옵션을 넣는 경우가 있음
seq_cst만 알면됨. 이것만 쓰면 된다. 다른걸 사용하면 위험..

멀스 기법 비교
no lock		50-	1607
atomix<int>	100-	708	-> 이걸 사용하는 이유
peterson		99-	2368
peterson_atomic	100-	4000
peterson_atf	100-	2400

aft는 에러날 확률이 줄어든거지 에러가 날 수있다. 

flag만 atomic으로 만들면?
정확한 결과가 나오지 않음.
컴파일러가 마음대로 순서 바꾼다.
atomic한 메모리 사이에 있는것들은 atomic하다. => 보장할 수 없다. 순서가 중요한건 다 atomic 메모리를 사용해야한다.

스레드끼리 데이터를 주고 받는 것 -> 동기화
자료구조는 atomic하게 동작하지 않는다.

sum += 2 		-> atomic
sum = sum +2 	-> atomic x

효율적인 자료구조★
결과가 올바르고 성능이 빠른것
mutex가 있으면 병렬성이 없음.-> 성능이 올라가지 않음
동시에 실행되지 않고 스레드가 멈추는게 성능 저하의 주범
상대방이 flag를 바꿔주기를 기다린다 -> 이런 코드를 쓰면 lock이랑 같다. 피터슨에 while이 있었음.
상대방 스레드에 의존적이지 않게 해야. 내가 할일이 있으면 그냥 하도록 해야한다.

기존 기다리는거 -> 블럭킹
atomic을 쓰는건 넌블럭킹

우선순위가 정해져있는경우 -> enqueue가 더 우선순위가 높다.  enqueue를 빨리해야 프로그램이 빨리 끝남.
cpu의 코어 개수보다 많은 스레드를 절대 만들지 말 것 !! cpu 전체가 먹통이 될 수 있다.

lock free가 더 많음. 모든이 아닌 적어도 한 개가 유한한 단계에 마침.
나머지가 영원히 뒤로 밀리면 안됨. 나머지도 유한한 단계에 끝나야. 유한한 단계 x메소드의 개수 에 끝나야.
옆애가 밀리면 다른애가 끝난다.

wait -free 보다 lock-free가 더 성능이 좋다.


































































